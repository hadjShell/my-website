import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as a,d as s,o as i}from"./app-BfAiRTR8.js";const t={};function l(r,n){return i(),a("div",null,[...n[0]||(n[0]=[s(`<h2 id="üß†-concept" tabindex="-1"><a class="header-anchor" href="#üß†-concept"><span>üß† Concept</span></a></h2><ul><li><p>A binary tree that <strong><code>left.val &lt; root.val &lt; right.val</code></strong></p></li><li><p>For each node in a BST, <strong>its left subtree and right subtree are BST</strong></p></li><li><p>Searching, insertion, deletion - <code>O(log N)</code> for balanced BST, <code>O(N)</code> for unbalanced BST</p><ul><li><p>For a perfect binary tree, its level is equal to <code>log (N + 1)</code>, which is approximately <code>log N</code></p></li><li><div class="language-txt line-numbers-mode" data-highlighter="shiki" data-ext="txt" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-txt"><span class="line"><span>Algorithm findBST</span></span>
<span class="line"><span>Inputs c: Pointer; key: Integer</span></span>
<span class="line"><span>Returns Pointer</span></span>
<span class="line"><span></span></span>
<span class="line"><span>Begin</span></span>
<span class="line"><span>if c = NULL then return NULL</span></span>
<span class="line"><span>else</span></span>
<span class="line"><span>if c.key() = key then return c</span></span>
<span class="line"><span>if c.key() &gt; key then</span></span>
<span class="line"><span>return findBST(c.leftPTR(), key)</span></span>
<span class="line"><span>else</span></span>
<span class="line"><span>return findBST(c.rightPTR(), key)</span></span>
<span class="line"><span>End</span></span>
<span class="line"><span></span></span>
<span class="line"><span>c - pointer to current node</span></span>
<span class="line"><span>c.key() - value at node c</span></span>
<span class="line"><span>c.leftPTR() - pointer to left node at c</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul></li><li><p>Deletion</p><ul><li><p>Node with at most one subtree</p><ul><li>Simple delete and change the pointer if needed</li></ul></li><li><p>Root node &amp; nodes that have two subtrees</p><ul><li><p>Marked as deleted, or</p></li><li><p><strong>Minimum in right subtree</strong>, or</p><ul><li>Find next highest node N, i.e., go right then left as far as you can</li><li>Delete N (having at most one subtree)</li><li>Replace node deleting by node N</li></ul></li><li><p><strong>Maximum in left subtree</strong></p></li></ul></li></ul></li></ul><h2 id="üõ†Ô∏è-pattern" tabindex="-1"><a class="header-anchor" href="#üõ†Ô∏è-pattern"><span>üõ†Ô∏è Pattern</span></a></h2><ul><li><p>First of all, <strong>BST is a binary tree</strong></p></li><li><p><strong><code>left.val &lt; root.val &lt; right.val</code></strong></p></li><li><p>For each node in a BST, <strong>its left subtree and right subtree are BST</strong></p></li><li><p><strong>Inorder traversal returns an ascending list</strong></p></li><li><p>Âà©Áî® BST <strong>Â∑¶Â∞èÂè≥Â§ß</strong>ÁöÑÁâπÊÄßÊèêÂçáÁÆóÊ≥ïÊïàÁéá -&gt; <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(logN)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span></p></li></ul>`,4)])])}const c=e(t,[["render",l]]),d=JSON.parse(`{"path":"/leetcode/bst/concept.html","title":"Binary Search Tree Concept & Pattern","lang":"en-US","frontmatter":{"title":"Binary Search Tree Concept & Pattern","author":"David Zhang aka Hadjshell","order":1,"isOriginal":true,"footer":false,"editLink":false,"description":"üß† Concept A binary tree that left.val < root.val < right.val For each node in a BST, its left subtree and right subtree are BST Searching, insertion, deletion - O(log N) for ba...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Binary Search Tree Concept & Pattern\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-12-22T12:14:07.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"David Zhang aka Hadjshell\\"}]}"],["meta",{"property":"og:url","content":"https://hadjshell.netlify.app/leetcode/bst/concept.html"}],["meta",{"property":"og:site_name","content":"Hadjshell's Field"}],["meta",{"property":"og:title","content":"Binary Search Tree Concept & Pattern"}],["meta",{"property":"og:description","content":"üß† Concept A binary tree that left.val < root.val < right.val For each node in a BST, its left subtree and right subtree are BST Searching, insertion, deletion - O(log N) for ba..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"en-US"}],["meta",{"property":"og:updated_time","content":"2025-12-22T12:14:07.000Z"}],["meta",{"property":"article:author","content":"David Zhang aka Hadjshell"}],["meta",{"property":"article:modified_time","content":"2025-12-22T12:14:07.000Z"}]]},"git":{"createdTime":1766405647000,"updatedTime":1766405647000,"contributors":[{"name":"Âº†ÂÆ∂Ê∫ê","username":"","email":"davidzhang0880@gmail.com","commits":1}]},"readingTime":{"minutes":0.8,"words":241},"filePathRelative":"leetcode/bst/concept.md","excerpt":"<h2>üß† Concept</h2>\\n<ul>\\n<li>\\n<p>A binary tree that <strong><code>left.val &lt; root.val &lt; right.val</code></strong></p>\\n</li>\\n<li>\\n<p>For each node in a BST, <strong>its left subtree and right subtree are BST</strong></p>\\n</li>\\n<li>\\n<p>Searching, insertion, deletion - <code>O(log N)</code> for balanced BST, <code>O(N)</code> for unbalanced BST</p>\\n<ul>\\n<li>\\n<p>For a perfect binary tree, its level is equal to <code>log (N + 1)</code>, which is approximately <code>log N</code></p>\\n</li>\\n<li>\\n<div class=\\"language-txt line-numbers-mode\\" data-highlighter=\\"shiki\\" data-ext=\\"txt\\" style=\\"--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34\\"><pre class=\\"shiki shiki-themes one-light one-dark-pro vp-code\\"><code class=\\"language-txt\\"><span class=\\"line\\"><span>Algorithm findBST</span></span>\\n<span class=\\"line\\"><span>Inputs c: Pointer; key: Integer</span></span>\\n<span class=\\"line\\"><span>Returns Pointer</span></span>\\n<span class=\\"line\\"><span></span></span>\\n<span class=\\"line\\"><span>Begin</span></span>\\n<span class=\\"line\\"><span>if c = NULL then return NULL</span></span>\\n<span class=\\"line\\"><span>else</span></span>\\n<span class=\\"line\\"><span>if c.key() = key then return c</span></span>\\n<span class=\\"line\\"><span>if c.key() &gt; key then</span></span>\\n<span class=\\"line\\"><span>return findBST(c.leftPTR(), key)</span></span>\\n<span class=\\"line\\"><span>else</span></span>\\n<span class=\\"line\\"><span>return findBST(c.rightPTR(), key)</span></span>\\n<span class=\\"line\\"><span>End</span></span>\\n<span class=\\"line\\"><span></span></span>\\n<span class=\\"line\\"><span>c - pointer to current node</span></span>\\n<span class=\\"line\\"><span>c.key() - value at node c</span></span>\\n<span class=\\"line\\"><span>c.leftPTR() - pointer to left node at c</span></span></code></pre>\\n<div class=\\"line-numbers\\" aria-hidden=\\"true\\" style=\\"counter-reset:line-number 0\\"><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div></div></div></li>\\n</ul>\\n</li>\\n<li>\\n<p>Deletion</p>\\n<ul>\\n<li>\\n<p>Node with at most one subtree</p>\\n<ul>\\n<li>Simple delete and change the pointer if needed</li>\\n</ul>\\n</li>\\n<li>\\n<p>Root node &amp; nodes that have two subtrees</p>\\n<ul>\\n<li>\\n<p>Marked as deleted, or</p>\\n</li>\\n<li>\\n<p><strong>Minimum in right subtree</strong>, or</p>\\n<ul>\\n<li>Find next highest node N, i.e., go right then left as far as you can</li>\\n<li>Delete N (having at most one subtree)</li>\\n<li>Replace node deleting by node N</li>\\n</ul>\\n</li>\\n<li>\\n<p><strong>Maximum in left subtree</strong></p>\\n</li>\\n</ul>\\n</li>\\n</ul>\\n</li>\\n</ul>","copyright":{"author":"David Zhang aka Hadjshell"},"autoDesc":true}`);export{c as comp,d as data};
